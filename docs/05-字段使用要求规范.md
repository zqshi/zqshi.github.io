# 数字员工系统字段使用要求规范
## Digital Employee System Field Usage Requirements v1.0

### 📋 文档信息
- **文档版本**: v1.0
- **创建日期**: 2024-01-24
- **适用范围**: 数字员工系统所有数据表字段设计
- **维护部门**: 数据标准化组

---

## 🎯 字段设计基础原则

### 1.1 字段命名规范

#### 1.1.1 命名约定

| 规则类别 | 命名规范 | 示例 | 说明 |
|----------|----------|------|------|
| **基础规则** | 小写字母+下划线 | `user_name`, `created_at` | 统一风格，便于维护 |
| **布尔字段** | is_/has_/can_前缀 | `is_active`, `has_permission` | 明确表示布尔含义 |
| **时间字段** | 以_at/_on结尾 | `created_at`, `expired_on` | 明确时间语义 |
| **数量字段** | _count/_num结尾 | `task_count`, `retry_num` | 明确数量含义 |
| **标识字段** | _id结尾 | `user_id`, `agent_id` | 明确标识关系 |
| **状态字段** | status/state | `task_status`, `agent_state` | 明确状态含义 |
| **配置字段** | config/settings | `agent_config`, `user_settings` | 明确配置用途 |

#### 1.1.2 字段命名禁用词汇

```yaml
# 禁用的字段名称
forbidden_names:
  - name: "id"
    reason: "太过通用，应使用具体的{table}_id"
    alternative: "user_id, agent_id, task_id"
    
  - name: "data"
    reason: "语义不明确"
    alternative: "input_data, config_data, meta_data"
    
  - name: "value"
    reason: "太过通用"
    alternative: "config_value, setting_value"
    
  - name: "type"
    reason: "可能与SQL关键字冲突"
    alternative: "user_type, agent_type, task_type"
    
  - name: "order"
    reason: "SQL关键字"
    alternative: "sort_order, display_order"
    
  - name: "key"
    reason: "SQL关键字"
    alternative: "config_key, cache_key"
```

#### 1.1.3 字段命名最佳实践

```sql
-- ✅ 好的命名示例
CREATE TABLE good_naming_example (
    user_id UUID PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email_address VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP,
    failed_login_count INTEGER DEFAULT 0,
    user_preferences JSONB DEFAULT '{}',
    profile_image_url VARCHAR(500)
);

-- ❌ 不好的命名示例
CREATE TABLE bad_naming_example (
    id UUID PRIMARY KEY,           -- 太通用
    name VARCHAR(50),              -- 不明确是什么名称
    email VARCHAR(255),            -- 缺少语义
    active BOOLEAN,                -- 应该是is_active
    created TIMESTAMP,             -- 应该是created_at
    login TIMESTAMP,               -- 不明确是哪种登录时间
    count INTEGER,                 -- 什么的计数？
    data JSONB,                    -- 什么数据？
    url VARCHAR(500)               -- 什么URL？
);
```

### 1.2 字段类型选择标准

#### 1.2.1 PostgreSQL字段类型映射表

| 业务数据类型 | PostgreSQL类型 | 长度/精度 | 使用场景 | 注意事项 |
|-------------|----------------|-----------|----------|----------|
| **主键标识** | UUID | 36字符 | 所有主键、外键 | 使用uuid_generate_v4() |
| **短文本** | VARCHAR(n) | 1-255 | 用户名、标题、代码 | 明确最大长度 |
| **长文本** | TEXT | 无限制 | 描述、内容、日志 | 避免滥用 |
| **整数** | INTEGER | 4字节 | 计数、序号、枚举 | -2^31 到 2^31-1 |
| **大整数** | BIGINT | 8字节 | 大数值、时间戳 | -2^63 到 2^63-1 |
| **小整数** | SMALLINT | 2字节 | 等级、状态码 | -32768 到 32767 |
| **精确数值** | DECIMAL(p,s) | 变长 | 金额、比率、分数 | 避免浮点误差 |
| **布尔值** | BOOLEAN | 1字节 | 开关、标记 | true/false/null |
| **时间戳** | TIMESTAMP | 8字节 | 创建时间、更新时间 | 使用UTC时区 |
| **日期** | DATE | 4字节 | 生日、到期日 | 不包含时间 |
| **JSON数据** | JSONB | 变长 | 配置、设置、灵活数据 | 建议使用JSONB |
| **IP地址** | INET | 变长 | 客户端IP | 支持IPv4/IPv6 |
| **二进制** | BYTEA | 变长 | 加密数据、文件 | 少量使用 |

#### 1.2.2 字段长度设计标准

```sql
-- 字段长度设计标准
CREATE TABLE field_length_standards (
    -- 用户相关字段
    username VARCHAR(50),              -- 用户名：通常20-50字符
    email VARCHAR(255),                -- 邮箱：标准最大长度
    phone VARCHAR(20),                 -- 电话：国际格式
    display_name VARCHAR(100),         -- 显示名：支持中英文
    
    -- 系统标识字段
    system_code VARCHAR(20),           -- 系统代码：简短标识
    business_id VARCHAR(50),           -- 业务ID：可能包含前缀
    external_id VARCHAR(100),          -- 外部系统ID：预留空间
    
    -- 内容字段
    title VARCHAR(200),                -- 标题：支持较长标题
    short_description VARCHAR(500),     -- 短描述：摘要信息
    full_description TEXT,             -- 完整描述：无长度限制
    
    -- URL和路径
    url VARCHAR(500),                  -- URL：现代URL可能很长
    file_path VARCHAR(255),            -- 文件路径：文件系统限制
    
    -- 状态和类型
    status VARCHAR(20),                -- 状态：枚举值
    category VARCHAR(50),              -- 分类：较短分类名
    
    -- 密码和安全
    password_hash VARCHAR(255),        -- 密码哈希：固定算法长度
    token VARCHAR(500),                -- 令牌：JWT等可能较长
    secret_key VARCHAR(100)            -- 密钥：安全密钥
);
```

---

## 📊 标准字段定义

### 2.1 审计字段标准

#### 2.1.1 必需审计字段

```sql
-- 标准审计字段模板
CREATE TABLE audit_fields_template (
    -- 业务主键
    record_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    
    -- 必需审计字段
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
        CONSTRAINT ck_created_at_not_future CHECK (created_at <= CURRENT_TIMESTAMP),
    
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
        CONSTRAINT ck_updated_at_after_created CHECK (updated_at >= created_at),
    
    created_by UUID NOT NULL
        CONSTRAINT fk_created_by FOREIGN KEY (created_by) REFERENCES users(user_id),
    
    updated_by UUID
        CONSTRAINT fk_updated_by FOREIGN KEY (updated_by) REFERENCES users(user_id),
    
    -- 可选审计字段
    deleted_at TIMESTAMP NULL
        CONSTRAINT ck_deleted_at_after_created CHECK (deleted_at IS NULL OR deleted_at >= created_at),
    
    deleted_by UUID
        CONSTRAINT fk_deleted_by FOREIGN KEY (deleted_by) REFERENCES users(user_id)
        CONSTRAINT ck_deleted_by_with_deleted_at CHECK (
            (deleted_at IS NULL AND deleted_by IS NULL) OR 
            (deleted_at IS NOT NULL AND deleted_by IS NOT NULL)
        ),
    
    -- 版本控制字段
    version INTEGER NOT NULL DEFAULT 1
        CONSTRAINT ck_version_positive CHECK (version > 0),
    
    -- 行锁字段(乐观锁)
    row_version BIGINT NOT NULL DEFAULT 1
        CONSTRAINT ck_row_version_positive CHECK (row_version > 0)
);

-- 自动更新触发器
CREATE OR REPLACE FUNCTION update_audit_fields()
RETURNS TRIGGER AS $$
BEGIN
    -- 更新时间
    NEW.updated_at = CURRENT_TIMESTAMP;
    
    -- 版本号递增
    NEW.version = OLD.version + 1;
    NEW.row_version = OLD.row_version + 1;
    
    -- 软删除处理
    IF NEW.deleted_at IS NOT NULL AND OLD.deleted_at IS NULL THEN
        NEW.deleted_at = CURRENT_TIMESTAMP;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

#### 2.1.2 审计字段使用规范

| 字段名 | 数据类型 | 是否必需 | 默认值 | 使用说明 |
|--------|----------|----------|--------|----------|
| **created_at** | TIMESTAMP | 是 | CURRENT_TIMESTAMP | 记录创建时间，不可修改 |
| **updated_at** | TIMESTAMP | 是 | CURRENT_TIMESTAMP | 记录最后更新时间，自动更新 |
| **created_by** | UUID | 是 | 无 | 记录创建者，引用users表 |
| **updated_by** | UUID | 否 | NULL | 记录最后更新者，引用users表 |
| **deleted_at** | TIMESTAMP | 否 | NULL | 软删除时间，NULL表示未删除 |
| **deleted_by** | UUID | 否 | NULL | 软删除操作者，配合deleted_at使用 |
| **version** | INTEGER | 可选 | 1 | 业务版本号，用于版本管理 |
| **row_version** | BIGINT | 可选 | 1 | 行版本号，用于乐观锁 |

### 2.2 状态字段标准

#### 2.2.1 通用状态枚举

```sql
-- 通用状态字段定义
CREATE TYPE general_status AS ENUM (
    'active',        -- 活跃
    'inactive',      -- 非活跃
    'suspended',     -- 暂停
    'deleted',       -- 已删除
    'draft',         -- 草稿
    'published',     -- 已发布
    'archived'       -- 已归档
);

-- 任务状态枚举
CREATE TYPE task_status AS ENUM (
    'pending',       -- 待处理
    'queued',        -- 已排队
    'assigned',      -- 已分配
    'running',       -- 运行中
    'paused',        -- 已暂停
    'completed',     -- 已完成
    'failed',        -- 已失败
    'cancelled',     -- 已取消
    'timeout',       -- 超时
    'retry'          -- 重试中
);

-- Agent健康状态枚举
CREATE TYPE health_status AS ENUM (
    'healthy',       -- 健康
    'degraded',      -- 降级
    'unhealthy',     -- 不健康
    'unknown',       -- 未知
    'maintenance'    -- 维护中
);

-- 使用示例
CREATE TABLE status_examples (
    record_id UUID PRIMARY KEY,
    general_status general_status NOT NULL DEFAULT 'active',
    task_status task_status,
    health_status health_status DEFAULT 'unknown',
    
    -- 如果不使用自定义类型，使用VARCHAR+CHECK约束
    priority VARCHAR(20) NOT NULL DEFAULT 'normal'
        CONSTRAINT ck_priority CHECK (priority IN ('low', 'normal', 'high', 'urgent', 'critical')),
    
    approval_status VARCHAR(20)
        CONSTRAINT ck_approval_status CHECK (approval_status IN ('pending', 'approved', 'rejected', 'cancelled'))
);
```

#### 2.2.2 状态字段设计规则

```yaml
# 状态字段设计规则
status_field_rules:
  naming:
    - pattern: "{entity}_status" # 如 task_status, user_status
    - alternative: "status" # 如果上下文明确
    
  data_type:
    - preferred: "ENUM" # 推荐使用自定义枚举
    - alternative: "VARCHAR(20) + CHECK constraint" # 备选方案
    
  default_value:
    - required: true
    - common_defaults: ["active", "pending", "draft"]
    
  constraints:
    - check_constraint: "必须定义有效值范围"
    - not_null: "状态字段通常不允许NULL"
    
  indexing:
    - index_required: true
    - composite_index: "考虑与时间字段组合索引"
```

### 2.3 配置字段标准

#### 2.3.1 JSON配置字段规范

```sql
-- JSON配置字段标准设计
CREATE TABLE json_config_standards (
    config_id UUID PRIMARY KEY,
    
    -- 结构化配置(推荐JSONB)
    system_config JSONB NOT NULL DEFAULT '{}'
        CONSTRAINT ck_system_config_object CHECK (jsonb_typeof(system_config) = 'object'),
    
    -- 用户设置
    user_preferences JSONB DEFAULT '{}'
        CONSTRAINT ck_user_preferences_object CHECK (jsonb_typeof(user_preferences) = 'object'),
    
    -- 能力列表(数组类型)
    capabilities JSONB DEFAULT '[]'
        CONSTRAINT ck_capabilities_array CHECK (jsonb_typeof(capabilities) = 'array'),
    
    -- 标签列表
    tags JSONB DEFAULT '[]'
        CONSTRAINT ck_tags_array CHECK (jsonb_typeof(tags) = 'array'),
    
    -- 元数据(灵活结构)
    metadata JSONB DEFAULT '{}',
    
    -- 约束规则(复杂结构)
    constraint_rules JSONB DEFAULT '{}'
        CONSTRAINT ck_constraint_rules_structure CHECK (
            jsonb_typeof(constraint_rules) = 'object' AND
            (constraint_rules ? 'required' OR constraint_rules = '{}')
        )
);

-- JSON字段索引策略
-- 1. GIN索引用于复杂查询
CREATE INDEX idx_system_config_gin ON json_config_standards USING GIN (system_config);

-- 2. 表达式索引用于特定键查询
CREATE INDEX idx_config_max_tasks ON json_config_standards 
    USING BTREE ((system_config->>'max_concurrent_tasks'));

-- 3. 条件索引用于特定值
CREATE INDEX idx_config_enabled ON json_config_standards 
    USING BTREE ((system_config->>'enabled')) 
    WHERE (system_config->>'enabled') = 'true';

-- JSON字段标准格式示例
INSERT INTO json_config_standards (config_id, system_config, capabilities, tags) VALUES 
(
    uuid_generate_v4(),
    '{
        "max_concurrent_tasks": 10,
        "timeout_seconds": 300,
        "enabled": true,
        "retry_policy": {
            "max_retries": 3,
            "retry_delay": 1000
        },
        "resource_limits": {
            "memory_mb": 512,
            "cpu_cores": 0.5
        }
    }',
    '["data_processing", "api_integration", "report_generation"]',
    '["production", "high-performance", "agent-v2"]'
);
```

#### 2.3.2 JSON字段验证规则

```sql
-- JSON字段验证函数
CREATE OR REPLACE FUNCTION validate_agent_config(config JSONB)
RETURNS BOOLEAN AS $$
BEGIN
    -- 检查必需键
    IF NOT (config ? 'max_concurrent_tasks' AND config ? 'timeout_seconds') THEN
        RETURN FALSE;
    END IF;
    
    -- 检查数据类型
    IF jsonb_typeof(config->'max_concurrent_tasks') != 'number' OR
       jsonb_typeof(config->'timeout_seconds') != 'number' THEN
        RETURN FALSE;
    END IF;
    
    -- 检查数值范围
    IF (config->>'max_concurrent_tasks')::INTEGER <= 0 OR
       (config->>'max_concurrent_tasks')::INTEGER > 100 THEN
        RETURN FALSE;
    END IF;
    
    IF (config->>'timeout_seconds')::INTEGER <= 0 OR
       (config->>'timeout_seconds')::INTEGER > 3600 THEN
        RETURN FALSE;
    END IF;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- 在表中使用验证函数
ALTER TABLE agents ADD CONSTRAINT ck_agents_config_valid 
    CHECK (validate_agent_config(config));
```

---

## 🔒 安全字段要求

### 3.1 敏感数据字段

#### 3.1.1 密码字段标准

```sql
-- 密码相关字段标准
CREATE TABLE password_field_standards (
    user_id UUID PRIMARY KEY,
    
    -- 密码哈希(必需)
    password_hash VARCHAR(255) NOT NULL
        CONSTRAINT ck_password_hash_format CHECK (
            password_hash ~ '^[\$]2[abxy][\$][0-9]{2}[\$][./A-Za-z0-9]{53}$' -- bcrypt格式
        ),
    
    -- 密码盐(如果单独存储)
    password_salt VARCHAR(32),
    
    -- 密码历史(防止重复使用)
    password_history JSONB DEFAULT '[]'
        CONSTRAINT ck_password_history_array CHECK (jsonb_typeof(password_history) = 'array'),
    
    -- 密码策略
    password_policy JSONB DEFAULT '{
        "min_length": 8,
        "require_uppercase": true,
        "require_lowercase": true,
        "require_numbers": true,
        "require_symbols": true,
        "max_age_days": 90
    }',
    
    -- 密码元数据
    password_created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    password_expires_at TIMESTAMP,
    must_change_password BOOLEAN NOT NULL DEFAULT false,
    
    -- 安全状态
    failed_login_attempts INTEGER NOT NULL DEFAULT 0
        CONSTRAINT ck_failed_attempts_positive CHECK (failed_login_attempts >= 0),
    locked_until TIMESTAMP,
    last_password_change TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 密码相关索引
CREATE INDEX idx_password_expires ON password_field_standards(password_expires_at);
CREATE INDEX idx_password_locked ON password_field_standards(locked_until);
CREATE INDEX idx_password_must_change ON password_field_standards(must_change_password);
```

#### 3.1.2 加密字段标准

```sql
-- 加密字段标准设计
CREATE TABLE encrypted_field_standards (
    record_id UUID PRIMARY KEY,
    
    -- 原始字段(明文，用于查询的哈希)
    email_hash VARCHAR(64) NOT NULL -- SHA-256哈希，用于查询
        CONSTRAINT ck_email_hash_format CHECK (email_hash ~ '^[a-f0-9]{64}$'),
    
    -- 加密字段(密文)
    email_encrypted BYTEA NOT NULL, -- 加密存储的实际邮箱
    
    -- 电话号码(同样处理)
    phone_hash VARCHAR(64) -- 可选，电话号码哈希
        CONSTRAINT ck_phone_hash_format CHECK (phone_hash ~ '^[a-f0-9]{64}$'),
    phone_encrypted BYTEA, -- 加密的电话号码
    
    -- 身份证号码等敏感信息
    id_card_hash VARCHAR(64) -- 身份证哈希
        CONSTRAINT ck_id_card_hash_format CHECK (id_card_hash ~ '^[a-f0-9]{64}$'),
    id_card_encrypted BYTEA, -- 加密的身份证号码
    
    -- 加密元数据
    encryption_version INTEGER NOT NULL DEFAULT 1, -- 加密版本
    encrypted_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    encryption_key_id VARCHAR(50), -- 密钥ID(用于密钥轮换)
    
    -- 审计字段
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 加密/解密辅助函数
CREATE OR REPLACE FUNCTION encrypt_sensitive_data(
    plain_text TEXT,
    encryption_key TEXT
) RETURNS BYTEA AS $$
BEGIN
    -- 使用pgcrypto扩展进行加密
    RETURN pgp_sym_encrypt(plain_text, encryption_key);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION decrypt_sensitive_data(
    encrypted_data BYTEA,
    encryption_key TEXT
) RETURNS TEXT AS $$
BEGIN
    -- 解密数据
    RETURN pgp_sym_decrypt(encrypted_data, encryption_key);
EXCEPTION
    WHEN OTHERS THEN
        -- 解密失败返回NULL
        RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 生成哈希函数
CREATE OR REPLACE FUNCTION generate_data_hash(data TEXT)
RETURNS VARCHAR(64) AS $$
BEGIN
    RETURN encode(digest(data, 'sha256'), 'hex');
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

### 3.2 访问控制字段

#### 3.2.1 权限相关字段

```sql
-- 权限字段标准
CREATE TYPE permission_level AS ENUM ('none', 'read', 'write', 'admin', 'owner');
CREATE TYPE access_scope AS ENUM ('global', 'organization', 'department', 'team', 'personal');

CREATE TABLE permission_field_standards (
    permission_id UUID PRIMARY KEY,
    
    -- 权限主体
    subject_id UUID NOT NULL, -- 用户或角色ID
    subject_type VARCHAR(20) NOT NULL 
        CONSTRAINT ck_subject_type CHECK (subject_type IN ('user', 'role', 'group')),
    
    -- 权限对象
    resource_id UUID, -- 资源ID(可选，NULL表示全局)
    resource_type VARCHAR(50) NOT NULL, -- 资源类型
    
    -- 权限级别
    permission_level permission_level NOT NULL DEFAULT 'none',
    access_scope access_scope NOT NULL DEFAULT 'personal',
    
    -- 权限条件
    conditions JSONB DEFAULT '{}' -- 额外的权限条件
        CONSTRAINT ck_conditions_object CHECK (jsonb_typeof(conditions) = 'object'),
    
    -- 权限约束
    ip_restrictions JSONB DEFAULT '[]' -- IP地址限制
        CONSTRAINT ck_ip_restrictions_array CHECK (jsonb_typeof(ip_restrictions) = 'array'),
    time_restrictions JSONB DEFAULT '{}' -- 时间限制
        CONSTRAINT ck_time_restrictions_object CHECK (jsonb_typeof(time_restrictions) = 'object'),
    
    -- 生效时间
    effective_from TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    effective_until TIMESTAMP, -- NULL表示永久有效
    
    -- 权限状态
    is_active BOOLEAN NOT NULL DEFAULT true,
    is_inherited BOOLEAN NOT NULL DEFAULT false, -- 是否继承权限
    
    -- 审计字段
    granted_by UUID NOT NULL
        CONSTRAINT fk_granted_by FOREIGN KEY (granted_by) REFERENCES users(user_id),
    granted_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- 约束
    CONSTRAINT ck_effective_period CHECK (
        effective_until IS NULL OR effective_until > effective_from
    ),
    CONSTRAINT uk_permission_unique UNIQUE (subject_id, resource_id, resource_type)
);

-- 权限检查函数
CREATE OR REPLACE FUNCTION check_permission(
    p_subject_id UUID,
    p_resource_type VARCHAR(50),
    p_resource_id UUID DEFAULT NULL,
    p_required_level permission_level DEFAULT 'read'
) RETURNS BOOLEAN AS $$
DECLARE
    user_permission permission_level;
BEGIN
    -- 查询用户权限
    SELECT permission_level INTO user_permission
    FROM permission_field_standards
    WHERE subject_id = p_subject_id
      AND resource_type = p_resource_type
      AND (resource_id = p_resource_id OR resource_id IS NULL)
      AND is_active = true
      AND effective_from <= CURRENT_TIMESTAMP
      AND (effective_until IS NULL OR effective_until > CURRENT_TIMESTAMP)
    ORDER BY 
        CASE WHEN resource_id IS NOT NULL THEN 1 ELSE 2 END, -- 具体权限优先
        permission_level DESC
    LIMIT 1;
    
    -- 权限级别比较
    RETURN CASE 
        WHEN user_permission IS NULL THEN false
        WHEN p_required_level = 'none' THEN true
        WHEN p_required_level = 'read' THEN user_permission IN ('read', 'write', 'admin', 'owner')
        WHEN p_required_level = 'write' THEN user_permission IN ('write', 'admin', 'owner')
        WHEN p_required_level = 'admin' THEN user_permission IN ('admin', 'owner')
        WHEN p_required_level = 'owner' THEN user_permission = 'owner'
        ELSE false
    END;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

## 📈 性能相关字段

### 4.1 索引优化字段

#### 4.1.1 查询优化字段设计

```sql
-- 查询优化字段标准
CREATE TABLE query_optimization_fields (
    record_id UUID PRIMARY KEY,
    
    -- 主要查询字段(必须建索引)
    status VARCHAR(20) NOT NULL,
    category VARCHAR(50),
    priority INTEGER NOT NULL DEFAULT 5,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- 复合查询字段(建复合索引)
    tenant_id UUID NOT NULL, -- 多租户字段
    organization_id UUID,
    department_id UUID,
    
    -- 排序字段
    sort_order INTEGER NOT NULL DEFAULT 0,
    display_order INTEGER,
    
    -- 统计字段(避免实时计算)
    view_count INTEGER NOT NULL DEFAULT 0,
    like_count INTEGER NOT NULL DEFAULT 0,
    comment_count INTEGER NOT NULL DEFAULT 0,
    
    -- 搜索优化字段
    search_keywords TEXT, -- 预处理的搜索关键词
    search_vector TSVECTOR, -- 全文搜索向量
    
    -- 缓存字段(避免JOIN查询)
    creator_name VARCHAR(100), -- 冗余创建者姓名
    last_modifier_name VARCHAR(100), -- 冗余最后修改者姓名
    
    -- 分区字段(用于表分区)
    partition_key DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- 软删除优化
    is_deleted BOOLEAN NOT NULL DEFAULT false, -- 替代deleted_at的布尔字段
    deleted_at TIMESTAMP,
    
    -- 约束
    CONSTRAINT ck_priority_range CHECK (priority BETWEEN 1 AND 10),
    CONSTRAINT ck_counts_positive CHECK (
        view_count >= 0 AND like_count >= 0 AND comment_count >= 0
    ),
    CONSTRAINT ck_soft_delete_consistency CHECK (
        (is_deleted = false AND deleted_at IS NULL) OR
        (is_deleted = true AND deleted_at IS NOT NULL)
    )
);

-- 索引策略
-- 1. 单字段索引(高频查询字段)
CREATE INDEX idx_query_opt_status ON query_optimization_fields(status);
CREATE INDEX idx_query_opt_category ON query_optimization_fields(category);
CREATE INDEX idx_query_opt_created_at ON query_optimization_fields(created_at);

-- 2. 复合索引(多条件查询)
CREATE INDEX idx_query_opt_tenant_status ON query_optimization_fields(tenant_id, status, created_at);
CREATE INDEX idx_query_opt_org_dept ON query_optimization_fields(organization_id, department_id);

-- 3. 部分索引(条件过滤)
CREATE INDEX idx_query_opt_active ON query_optimization_fields(status, priority) 
    WHERE is_deleted = false;

-- 4. 全文搜索索引
CREATE INDEX idx_query_opt_search ON query_optimization_fields USING GIN(search_vector);

-- 5. 表达式索引
CREATE INDEX idx_query_opt_month ON query_optimization_fields(date_trunc('month', created_at));
```

#### 4.1.2 分区字段标准

```sql
-- 分区表字段标准
CREATE TABLE partition_field_standards (
    record_id UUID NOT NULL,
    
    -- 时间分区字段(最常用)
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    partition_date DATE NOT NULL DEFAULT CURRENT_DATE, -- 专用分区字段
    
    -- 业务分区字段
    tenant_id UUID NOT NULL, -- 租户分区
    region_code VARCHAR(10), -- 地域分区
    data_type VARCHAR(50), -- 数据类型分区
    
    -- 哈希分区字段
    hash_key INTEGER NOT NULL DEFAULT (random() * 1000000)::INTEGER,
    
    -- 业务数据
    business_data JSONB,
    
    -- 主键必须包含分区键
    PRIMARY KEY (record_id, created_at)
) PARTITION BY RANGE (created_at);

-- 分区表创建示例
CREATE TABLE partition_field_standards_2024_01 PARTITION OF partition_field_standards
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- 分区表索引(每个分区都需要)
CREATE INDEX idx_partition_2024_01_tenant ON partition_field_standards_2024_01(tenant_id);
CREATE INDEX idx_partition_2024_01_region ON partition_field_standards_2024_01(region_code);
```

### 4.2 统计字段标准

#### 4.2.1 计数器字段设计

```sql
-- 统计计数器字段标准
CREATE TABLE counter_field_standards (
    entity_id UUID PRIMARY KEY,
    entity_type VARCHAR(50) NOT NULL,
    
    -- 基础计数器
    total_count INTEGER NOT NULL DEFAULT 0
        CONSTRAINT ck_total_count_positive CHECK (total_count >= 0),
    
    active_count INTEGER NOT NULL DEFAULT 0
        CONSTRAINT ck_active_count_positive CHECK (active_count >= 0),
    
    -- 状态计数器
    success_count INTEGER NOT NULL DEFAULT 0
        CONSTRAINT ck_success_count_positive CHECK (success_count >= 0),
    
    failed_count INTEGER NOT NULL DEFAULT 0
        CONSTRAINT ck_failed_count_positive CHECK (failed_count >= 0),
    
    -- 时间段计数器
    today_count INTEGER NOT NULL DEFAULT 0
        CONSTRAINT ck_today_count_positive CHECK (today_count >= 0),
    
    this_month_count INTEGER NOT NULL DEFAULT 0
        CONSTRAINT ck_this_month_count_positive CHECK (this_month_count >= 0),
    
    -- 累积计数器
    lifetime_count BIGINT NOT NULL DEFAULT 0
        CONSTRAINT ck_lifetime_count_positive CHECK (lifetime_count >= 0),
    
    -- 计算字段(派生)
    success_rate DECIMAL(5,2) GENERATED ALWAYS AS (
        CASE 
            WHEN (success_count + failed_count) > 0 
            THEN (success_count * 100.0) / (success_count + failed_count)
            ELSE 0
        END
    ) STORED,
    
    -- 统计元数据
    last_count_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    count_version INTEGER NOT NULL DEFAULT 1,
    
    -- 约束检查
    CONSTRAINT ck_active_not_exceed_total CHECK (active_count <= total_count),
    CONSTRAINT ck_success_fail_not_exceed_total CHECK (success_count + failed_count <= total_count)
);

-- 计数器更新函数
CREATE OR REPLACE FUNCTION increment_counter(
    p_entity_id UUID,
    p_counter_name VARCHAR(50),
    p_increment INTEGER DEFAULT 1
) RETURNS BOOLEAN AS $$
BEGIN
    EXECUTE format('
        UPDATE counter_field_standards 
        SET %I = %I + %L,
            last_count_update = CURRENT_TIMESTAMP,
            count_version = count_version + 1
        WHERE entity_id = %L',
        p_counter_name, p_counter_name, p_increment, p_entity_id
    );
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;
```

---

## 🔍 字段验证和约束

### 5.1 数据完整性约束

#### 5.1.1 CHECK约束标准

```sql
-- CHECK约束标准示例
CREATE TABLE field_constraint_standards (
    record_id UUID PRIMARY KEY,
    
    -- 数值范围约束
    age INTEGER 
        CONSTRAINT ck_age_range CHECK (age >= 0 AND age <= 150),
    
    score DECIMAL(5,2)
        CONSTRAINT ck_score_range CHECK (score >= 0.00 AND score <= 100.00),
    
    percentage DECIMAL(5,2)
        CONSTRAINT ck_percentage_range CHECK (percentage >= 0.00 AND percentage <= 100.00),
    
    -- 字符串格式约束
    email VARCHAR(255)
        CONSTRAINT ck_email_format CHECK (email ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    
    phone VARCHAR(20)
        CONSTRAINT ck_phone_format CHECK (phone ~ '^\+?[1-9]\d{1,14}$'),
    
    url VARCHAR(500)
        CONSTRAINT ck_url_format CHECK (url ~ '^https?://[^\s/$.?#].[^\s]*$'),
    
    -- 枚举值约束
    status VARCHAR(20)
        CONSTRAINT ck_status_values CHECK (status IN ('active', 'inactive', 'suspended', 'deleted')),
    
    -- 日期逻辑约束
    start_date DATE,
    end_date DATE,
    CONSTRAINT ck_date_range CHECK (end_date IS NULL OR end_date >= start_date),
    
    -- 条件约束
    is_premium BOOLEAN NOT NULL DEFAULT false,
    premium_expires_at TIMESTAMP,
    CONSTRAINT ck_premium_expiry CHECK (
        (is_premium = false) OR 
        (is_premium = true AND premium_expires_at IS NOT NULL)
    ),
    
    -- JSON结构约束
    config JSONB DEFAULT '{}',
    CONSTRAINT ck_config_structure CHECK (
        jsonb_typeof(config) = 'object' AND
        config ? 'version'
    ),
    
    -- 复合约束
    priority INTEGER DEFAULT 5,
    urgency_level VARCHAR(20) DEFAULT 'normal',
    CONSTRAINT ck_priority_urgency CHECK (
        (priority <= 3 AND urgency_level IN ('low', 'normal')) OR
        (priority BETWEEN 4 AND 7 AND urgency_level IN ('normal', 'high')) OR
        (priority > 7 AND urgency_level IN ('high', 'critical'))
    )
);
```

#### 5.1.2 自定义验证函数

```sql
-- 复杂验证函数
CREATE OR REPLACE FUNCTION validate_business_rules(
    p_record_type VARCHAR(50),
    p_data JSONB
) RETURNS BOOLEAN AS $$
BEGIN
    -- 根据记录类型执行不同验证
    CASE p_record_type
        WHEN 'user_profile' THEN
            -- 用户资料验证
            IF NOT (p_data ? 'username' AND p_data ? 'email') THEN
                RETURN FALSE;
            END IF;
            
            -- 用户名长度检查
            IF length(p_data->>'username') < 3 OR length(p_data->>'username') > 50 THEN
                RETURN FALSE;
            END IF;
            
        WHEN 'agent_config' THEN
            -- Agent配置验证
            IF NOT (p_data ? 'max_concurrent_tasks' AND p_data ? 'timeout_seconds') THEN
                RETURN FALSE;
            END IF;
            
            -- 数值范围检查
            IF (p_data->>'max_concurrent_tasks')::INTEGER <= 0 OR
               (p_data->>'max_concurrent_tasks')::INTEGER > 100 THEN
                RETURN FALSE;
            END IF;
            
        ELSE
            -- 默认验证
            RETURN jsonb_typeof(p_data) = 'object';
    END CASE;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- 在表中使用验证函数
ALTER TABLE some_table ADD CONSTRAINT ck_business_rules 
    CHECK (validate_business_rules(record_type, data_field));
```

### 5.2 引用完整性约束

#### 5.2.1 外键约束标准

```sql
-- 外键约束标准示例
CREATE TABLE foreign_key_standards (
    record_id UUID PRIMARY KEY,
    
    -- 基础外键(必需引用)
    created_by UUID NOT NULL
        CONSTRAINT fk_created_by 
        FOREIGN KEY (created_by) REFERENCES users(user_id)
        ON DELETE RESTRICT ON UPDATE CASCADE,
    
    -- 可选外键
    assigned_to UUID
        CONSTRAINT fk_assigned_to
        FOREIGN KEY (assigned_to) REFERENCES users(user_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
    
    -- 级联删除外键(谨慎使用)
    category_id UUID
        CONSTRAINT fk_category
        FOREIGN KEY (category_id) REFERENCES categories(category_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
    
    -- 多对多关系表的外键
    parent_id UUID
        CONSTRAINT fk_parent_record
        FOREIGN KEY (parent_id) REFERENCES foreign_key_standards(record_id)
        ON DELETE CASCADE ON UPDATE CASCADE,
    
    -- 条件外键(部分约束)
    approval_required BOOLEAN NOT NULL DEFAULT false,
    approver_id UUID,
    CONSTRAINT fk_approver
        FOREIGN KEY (approver_id) REFERENCES users(user_id)
        ON DELETE SET NULL ON UPDATE CASCADE,
    
    -- 约束：如果需要审批，必须有审批人
    CONSTRAINT ck_approval_logic CHECK (
        (approval_required = false) OR 
        (approval_required = true AND approver_id IS NOT NULL)
    )
);

-- 外键策略选择指南
/*
ON DELETE 策略:
- RESTRICT: 禁止删除(默认，最安全)
- CASCADE: 级联删除(谨慎使用)
- SET NULL: 设置为NULL(适合可选引用)
- SET DEFAULT: 设置为默认值

ON UPDATE 策略:
- CASCADE: 级联更新(推荐)
- RESTRICT: 禁止更新
- SET NULL: 设置为NULL
- SET DEFAULT: 设置为默认值
*/
```

---

## 📋 字段使用检查清单

### 6.1 设计阶段检查清单

#### 6.1.1 字段定义检查

- [ ] **命名规范**
  - [ ] 字段名使用小写+下划线格式
  - [ ] 布尔字段使用is_/has_/can_前缀
  - [ ] 时间字段使用_at/_on后缀
  - [ ] 避免使用SQL关键字作为字段名

- [ ] **数据类型选择**
  - [ ] 主键使用UUID类型
  - [ ] 文本长度根据业务需求合理设置
  - [ ] 数值类型选择符合精度要求
  - [ ] 时间类型统一使用TIMESTAMP
  - [ ] JSON数据使用JSONB类型

- [ ] **必需字段检查**
  - [ ] created_at字段已添加
  - [ ] updated_at字段已添加
  - [ ] created_by字段已添加
  - [ ] 主键字段正确设置

#### 6.1.2 约束和验证检查

- [ ] **约束定义**
  - [ ] NOT NULL约束合理设置
  - [ ] CHECK约束逻辑正确
  - [ ] 外键约束已建立
  - [ ] 唯一约束适当设置

- [ ] **安全性检查**
  - [ ] 敏感字段加密处理
  - [ ] 密码字段使用哈希存储
  - [ ] 权限控制字段完整
  - [ ] 审计字段齐全

### 6.2 实施阶段检查清单

#### 6.2.1 性能优化检查

- [ ] **索引策略**
  - [ ] 查询字段建立索引
  - [ ] 外键字段建立索引
  - [ ] 复合索引顺序合理
  - [ ] JSONB字段使用GIN索引

- [ ] **分区设计**
  - [ ] 大表考虑分区策略
  - [ ] 分区键包含在主键中
  - [ ] 分区表索引完整

#### 6.2.2 维护检查

- [ ] **触发器配置**
  - [ ] updated_at自动更新触发器
  - [ ] 审计触发器正确配置
  - [ ] 统计字段更新触发器

- [ ] **文档完整性**
  - [ ] 表注释完整
  - [ ] 字段注释准确
  - [ ] 约束注释清晰

---

## 📚 附录

### A.1 字段类型映射表

#### A.1.1 业务场景到数据类型映射

| 业务场景 | 推荐类型 | 备选类型 | 说明 |
|----------|----------|----------|------|
| **用户ID** | UUID | BIGINT | UUID更安全，BIGINT性能更好 |
| **用户名** | VARCHAR(50) | VARCHAR(100) | 根据业务需求调整 |
| **邮箱地址** | VARCHAR(255) | TEXT | 标准长度255足够 |
| **手机号码** | VARCHAR(20) | VARCHAR(15) | 支持国际格式 |
| **密码哈希** | VARCHAR(255) | CHAR(60) | bcrypt需要60字符 |
| **金额** | DECIMAL(12,2) | BIGINT | DECIMAL避免精度问题 |
| **百分比** | DECIMAL(5,2) | SMALLINT | 支持小数点 |
| **配置数据** | JSONB | TEXT | JSONB支持索引和查询 |
| **文件路径** | VARCHAR(500) | TEXT | 现代路径可能较长 |
| **IP地址** | INET | VARCHAR(45) | INET支持IPv4/IPv6 |

### A.2 常用验证正则表达式

```sql
-- 常用验证正则表达式
CREATE TABLE validation_patterns (
    pattern_name VARCHAR(50) PRIMARY KEY,
    pattern_regex TEXT NOT NULL,
    description TEXT,
    example_valid TEXT,
    example_invalid TEXT
);

INSERT INTO validation_patterns VALUES
('email', '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$', 'Email地址格式', 'user@example.com', 'invalid-email'),
('phone_intl', '^\+?[1-9]\d{1,14}$', '国际电话号码格式', '+8613800138000', '123'),
('url_http', '^https?://[^\s/$.?#].[^\s]*$', 'HTTP/HTTPS URL格式', 'https://example.com', 'ftp://example.com'),
('chinese_mobile', '^1[3-9]\d{9}$', '中国手机号码格式', '13800138000', '12345678901'),
('id_card_china', '^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$', '中国身份证号码格式', '110101199001011234', '123456'),
('username', '^[a-zA-Z0-9_]{3,20}$', '用户名格式(字母数字下划线)', 'user_123', 'us'),
('password_strong', '^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$', '强密码格式', 'Password123!', 'password'),
('ipv4', '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$', 'IPv4地址格式', '192.168.1.1', '256.1.1.1'),
('uuid', '^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$', 'UUID格式', 'f47ac10b-58cc-4372-a567-0e02b2c3d479', 'invalid-uuid'),
('version_semantic', '^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$', '语义化版本格式', '1.2.3', 'v1.2');
```

### A.3 字段设计最佳实践总结

1. **始终使用明确的字段名**：避免使用`id`, `data`, `value`等通用名称
2. **统一时间字段格式**：使用`created_at`, `updated_at`等标准命名
3. **合理设置字段长度**：根据实际业务需求设置，避免过长或过短
4. **必要的约束检查**：使用CHECK约束确保数据完整性
5. **敏感数据处理**：密码哈希存储，PII数据加密
6. **索引策略考虑**：为查询字段建立合适的索引
7. **审计字段完整**：包含必要的创建、更新、删除信息
8. **文档注释齐全**：为表和字段添加清晰的注释

---

**文档状态**: 正式发布  
**最后更新**: 2024-01-24  
**下次评审**: 2024-04-24  
**批准人**: 数据标准化委员会